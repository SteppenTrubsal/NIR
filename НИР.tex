\documentclass[a4paper,12pt]{article}

\usepackage{vkriate}

% \setFRMfontfamily{cmr}
% \setFRMdfontfamily{ptm}
\setFRMdfontsize{10}

% задает длину поля для подписи на титульной странице
\newFRMfield{xtitlesign}{32mm}

% поле для факультета или кафедры
\newFRMfield{fcath}{65mm}

%имя файла с библиографией в формате BibTex
\addbibresource{rbiblio.bib}

\begin{document}

% счетчики страниц, рисунков, таблиц
\regtotcounter{page}
\regtotcounter{figure}
\regtotcounter{table}

\renewcommand{\refname}{\centerline{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}} 
\renewcommand{\contentsname}{\centerline{СОДЕРЖАНИЕ}} 
%\renewcommand{\refname}{Список источников}  % По умолчанию "Список литературы" (article)
%\renewcommand{\bibname}{Литература}  % По умолчанию "Литература" (book и report)

\thispagestyle{empty}

\begin{center}\small
\textbf{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ}\\
ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ
ВЫСШЕГО  ОБРАЗОВАНИЯ\\
«Национальный исследовательский ядерный университет «МИФИ»\\
\textbf{Обнинский институт атомной энергетики} – \\
филиал федерального государственного автономного образовательного учреждения высшего\\
образования «Национальный исследовательский ядерный университет «МИФИ»\\
(ИАТЭ НИЯУ МИФИ)
\end{center}

\medskip

\begin{center}
\begin{tabular}{rl}
Отделение &
\useFRMfield{fcath}[\large Интеллектуальные кибернетические системы] \\
Направление подготовки &
\useFRMfield{fcath}[\large Информатика и вычислительная техника] \\
\end{tabular}
\end{center}

\vfill

\begin{center}\large
Научно-исследовательская работа

\medskip

\textbf{\Large
Анализ кодогенераторов для CANopen
}
\end{center}

\vspace{1cm}

\begin{center}
\begin{tabular*}{\textwidth}{lcr}
Студент группы ИВТ-Б22 &
\useFRMfield{xtitlesign} &
Карасев Н. А. \\
& & \\
Руководитель & & \\
инженер-программист &
\useFRMfield{xtitlesign} &
Жильцов Д. И.
\end{tabular*}
\end{center}

\vfill
\large

\begin{center}
Обнинск, 2025 г
\end{center}

\onehalfspacing
\pagebreak

\section*{\centering РЕФЕРАТ}

Работа \total{page} стр., \total{table} табл.,
\total{figure} рис., \totalmycitecounts\ ист.

Ключевые слова: CAN, CANOPEN, RUST

\begin{note}
    Написать нормальный реферат в конце
\end{note}

\pagebreak


\tableofcontents
\pagebreak

% Допускается определения, обозначения и сокращения приводить в одном структурном элементе «ОПРЕДЕЛЕНИЯ, ОБОЗНАЧЕНИЯ И СОКРАЩЕНИЯ».

\section*{\centering ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ}
В настоящем отчете о НИР применяют следующие термины с соответствующими определениями:
\begin{note}
    Позже
\end{note}

\pagebreak

\section*{\centering ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}
\begin{note}
    Позже
\end{note}

\pagebreak

\tocsection{ВВЕДЕНИЕ}
Для введения в столько конкретную тему стоит рассказать что вообще что такое CAN.

Допустим, вы являетесь инженером-электронщиком и разрабатываете различные электронные механизмы. У этих механизмов
вполне могут быть разнесены некоторые элементы, например какой-то датчик находится в одном месте, а блок обработки сигналов - в другом. В таком случае самым 
тривиальным решением будет взять и соединить их проводами! Однако такой подход не всегда является оптимальным и рано или поздно вы столкнётесь с проблемой
вездесущности этих самых проводов и кабелей. Огромные траты материалов на проводку - не самая большая проблема, намного хуже, на мой взгляд - обслуживать потом такую систему,
разобраться среди десятков и сотен различных проводов крайне сложно. Немного подумав, вы решаете объединить какие-то провода в жгуты, 
а следующим логическим шагом является переход от соединений "точка-точка" к шинной архитектуре, где по общей линии передаются сигналы между различными устройствами.

Но теперь вы сталкиваетесь с другой проблемой - как научить устройство принимать только те сигналы которые назначались конкретно ему ? 
Можно ввести какое-нибудь мультиплексирование по времени, но как быть с системами реального времени в которых дорога каждая секунда или крайне высока цена ошибки ?
Одним из способов заставить десятки электронных блоков в машине или промышленной установке обмениваться данными по одной общей шине так,
чтобы это было надёжно, предсказуемо по времени и устойчиво к помехам - является введение шины CAN.

Для решения вышеописанных проблем CAN предлагает простое и в то же время мощное решение - задание каждому сообщению своего идентификатора. В такой системе:

Каждый узел обрабатывает только то сообщение, которое назначалось конкретно ему;

Арбитраж происходит без разрушения кадра - при передаче сигналов от нескольких узлов одновременно победит то сообщение, у которого идентификатор приоритетнее

CAN самостоятельно контролирует корректность данных на уровне канала

Однако CAN - всего лишь шина, он даёт транспорт для коротких сообщений, но в сами сообщения он не лезет - для этого нужен какой-то надстроечный протокол на более абстрактном уровне.
Здесь и возникает CANopen.

CANopen задаёт общий прикладной каркас: определяет, как устройства описывают свои параметры, как ими управлять, как передавать “процессные” данные,
как диагностировать аварии, и как сеть в целом живёт от включения питания до штатной работы. Этот протокол

\begin{note}
Дописать введение и нормально подвести к конкретным решениям:
\begin{itemize}
    \item Zencan
    \item canopen
    \item canopen\_rust
    \item Вероятнее всего рассмотреть решения на C
\end{itemize}
\end{note}


\tocsection{ЗАКЛЮЧЕНИЕ}

\pagebreak

\addcontentsline{toc}{section}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\printbibliography

\pagebreak

\renewcommand{\appendixpagename}{\centering Приложения}

%\begin{appendices}

%\renewcommand{\thesection}{\Asbuk{section}}

%\makeatletter
%\renewcommand{\theProgram}{\thesection.\@arabic\c@Program}
%\makeatother

%\section{\centering}
%\setcounter{Program}{0}

%\begin{flushleft}
%\needspace{3\baselineskip}
%\captionof{Program}{Часть кода реализации класса HashMapValue}\label{app1}
%\begin{MyCodes}
%public class HashMapValue {
%    protected String filename;
%    protected HashMap<String, String> hashValue = new HashMap<>();
%    protected HashMap<String, Boolean> hashKeysFlag = new HashMap<>();
%}
%\end{MyCodes}
%\end{flushleft}

%\pagebreak

%\begin{flushleft}
%\captionof{Program}{Пример кода}\label{app2}
%\begin{MyCodes}
%код второго приложения
%\end{MyCodes}
%\end{flushleft}

%\end{appendices}

\end{document}
