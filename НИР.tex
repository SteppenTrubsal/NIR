\documentclass[a4paper,12pt]{article}

\usepackage{vkriate}

% \setFRMfontfamily{cmr}
% \setFRMdfontfamily{ptm}
\setFRMdfontsize{10}

% задает длину поля для подписи на титульной странице
\newFRMfield{xtitlesign}{32mm}

% поле для факультета или кафедры
\newFRMfield{fcath}{65mm}

%имя файла с библиографией в формате BibTex
\addbibresource{rbiblio.bib}

\begin{document}

% счетчики страниц, рисунков, таблиц
\regtotcounter{page}
\regtotcounter{figure}
\regtotcounter{table}

\renewcommand{\refname}{\centerline{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}} 
\renewcommand{\contentsname}{\centerline{СОДЕРЖАНИЕ}} 
%\renewcommand{\refname}{Список источников}  % По умолчанию "Список литературы" (article)
%\renewcommand{\bibname}{Литература}  % По умолчанию "Литература" (book и report)

\thispagestyle{empty}

\begin{center}\small
\textbf{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ}\\
ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ
ВЫСШЕГО  ОБРАЗОВАНИЯ\\
«Национальный исследовательский ядерный университет «МИФИ»\\
\textbf{Обнинский институт атомной энергетики} – \\
филиал федерального государственного автономного образовательного учреждения высшего\\
образования «Национальный исследовательский ядерный университет «МИФИ»\\
(ИАТЭ НИЯУ МИФИ)
\end{center}

\medskip

\begin{center}
\begin{tabular}{rl}
Отделение &
\useFRMfield{fcath}[\large Интеллектуальные кибернетические системы] \\
Направление подготовки &
\useFRMfield{fcath}[\large Информатика и вычислительная техника] \\
\end{tabular}
\end{center}

\vfill

\begin{center}\large
Научно-исследовательская работа

\medskip

\textbf{\Large
Анализ кодогенераторов для CANopen
}
\end{center}

\vspace{1cm}

\begin{center}
\begin{tabular*}{\textwidth}{lcr}
Студент группы ИВТ-Б22 &
\useFRMfield{xtitlesign} &
Карасев Н. А. \\
& & \\
Руководитель & & \\
инженер-программист &
\useFRMfield{xtitlesign} &
Жильцов Д. И.
\end{tabular*}
\end{center}

\vfill
\large

\begin{center}
Обнинск, 2025 г
\end{center}

\onehalfspacing
\pagebreak

\section*{\centering РЕФЕРАТ}

Работа \total{page} стр., \total{table} табл.,
\total{figure} рис., \totalmycitecounts\ ист.

Ключевые слова: CAN, CANOPEN, RUST

\begin{note}
    Написать нормальный реферат в конце
\end{note}

\pagebreak


\tableofcontents
\pagebreak

% Допускается определения, обозначения и сокращения приводить в одном структурном элементе «ОПРЕДЕЛЕНИЯ, ОБОЗНАЧЕНИЯ И СОКРАЩЕНИЯ».

\section*{\centering ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ}
В настоящем отчете о НИР применяют следующие термины с соответствующими определениями:
\begin{description}
  \item[Controller Area Network (CAN) ---] шина обмена сообщениями.
  \item[CANopen ---] протокол связи на основе CAN-шины. 
  \item[PDO (Process Data Object) ---] объект CANopen для передачи процессных данных в реальном времени; 
  как правило, это короткие сообщения с минимальными накладными расходами, предназначенные для циклического или событийного обмена. 
  \item[SDO (Service Data Object) ---] объект CANopen для конфигурации и диагностики устройства; 
  обеспечивает чтение и запись параметров словаря объектов и доступ к сервисной информации.
  \item[OD (Object Dictionary, словарь объектов) ---] структурированный набор параметров, команд и диагностических данных узла CANopen, 
  организованный как адресуемые записи, к которым обращаются стандартными механизмами протокола.
  \item[EDS (Electronic Data Sheet) ---] файл стандартизированного описания словаря объектов устройства CANopen, 
  используемый конфигураторами и сервисными утилитами для автоматической настройки и интеграции.
  \item[DCF (Device Configuration File) ---] файл конфигурации устройства CANopen, представляющий собой EDS с добавленными (или изменёнными) параметрами конкретной установки/проекта, применяемый для развёртывания одинаковых настроек.
\end{description}

\pagebreak

\section*{\centering ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}
В настоящем отчете о НИР применяют следующие сокращения и обозначения:

CAN --- Controller Area Network

SDO --- Service Data Objects

PDO --- Process Data Objects

OD --- Object Dictionary

EDS --- Electronic Data Sheet

DCF --- Device Configuration File

\pagebreak

\tocsection{ВВЕДЕНИЕ}
Для введения в столько конкретную тему стоит рассказать что вообще что такое CAN.

Допустим, вы являетесь инженером-электронщиком и разрабатываете различные электронные механизмы. У этих механизмов
вполне могут быть разнесены некоторые элементы, например какой-то датчик находится в одном месте, а блок обработки сигналов - в другом. В таком случае самым 
тривиальным решением будет взять и соединить их проводами! Однако такой подход не всегда является оптимальным и рано или поздно вы столкнётесь с проблемой
вездесущности этих самых проводов и кабелей. Огромные траты материалов на проводку - не самая большая проблема, намного хуже, на мой взгляд - обслуживать потом такую систему,
разобраться среди десятков и сотен различных проводов крайне сложно. Немного подумав, вы решаете объединить какие-то провода в жгуты, 
а следующим логическим шагом является переход от соединений "точка-точка" к шинной архитектуре, где по общей линии передаются сигналы между различными устройствами.

Но теперь вы сталкиваетесь с другой проблемой - как научить устройство принимать только те сигналы которые назначались конкретно ему ? 
Можно ввести какое-нибудь мультиплексирование по времени, но как быть с системами реального времени в которых дорога каждая секунда или крайне высока цена ошибки ?
Одним из способов заставить десятки электронных блоков в машине или промышленной установке обмениваться данными по одной общей шине так,
чтобы это было надёжно, предсказуемо по времени и устойчиво к помехам - является введение шины CAN.

Шина CAN (Controller Area Network) - это система связи, используемая в транспортных средствах/машинах для позволяют электронным блокам управления (ЭБУ) обмениваться данными друг с другом без участия главного компьютера. Например, шина CAN обеспечивает быстрый и надежный обмен информацией между тормозной системой и двигателем вашего автомобиля.  \cite{csse_canbus_intro_2025}

Для решения вышеописанных проблем CAN предлагает простое и в то же время мощное решение - задание каждому сообщению своего идентификатора. В такой системе:

Каждый узел обрабатывает только то сообщение, которое назначалось конкретно ему.

Арбитраж происходит без разрушения кадра - при передаче сигналов от нескольких узлов одновременно победит то сообщение, у которого идентификатор приоритетнее.

CAN самостоятельно контролирует корректность данных на уровне канала.

Однако CAN - всего лишь шина, он даёт транспорт для коротких сообщений, но в сами сообщения он не лезет - для этого нужен какой-то надстроечный протокол на более абстрактном уровне.
Здесь и возникает CANopen.

Стандарт CANopen полезен тем, что обеспечивает готовую к использованию совместимость между устройствами (узлами), например. промышленное оборудование. Кроме того, оно предоставляет стандартные методы конфигурирования устройств - в том числе и после установки. \cite{csse_canopen_intro_2025}

CANopen задаёт общий прикладной каркас: определяет, как устройства описывают свои параметры, как ими управлять, как передавать “процессные” данные,
как диагностировать аварии, и как сеть в целом живёт от включения питания до штатной работы. Этот протокол

Протокол имеет шесть ключевых особенностей \cite{csse_canopen_intro_2025}:

\begin{enumerate}
    \item \textbf{Три модели взаимодействия узлов.} 
    Master/\allowbreak slave, client/\allowbreak server и producer/\allowbreak consumer: Модель master/slave нужна там, где один узел (“master” или управляющий узел) 
    инициирует сетевые действия и управляет жизненным циклом других узлов (“slave”): запускает, останавливает, сбрасывает. 
    Модель client/server характерна для запросно-ответного обмена: один узел выступает клиентом, который читает или пишет параметр, другой - сервером, который обслуживает запрос.
    Наконец, producer/consumer описывает потоковую публикацию данных: один узел производит (producer) сообщения с измерениями/состояниями, а несколько потребителей (consumers) их принимают, не требуя явной адресации или подтверждения для каждого получателя.

    \item \textbf{Коммуникационные объекты и связанные с ними протоколы CANopen.} 
    В CANopen принято говорить, что обмен строится вокруг communication objects: стандартных типов сообщений, у которых есть ясная роль. 
    Два наиболее заметных примера - SDO и PDO:
    \begin{itemize}
        \item SDO (Service Data Objects) - это “сервисный” канал, используемый в первую очередь для конфигурации и диагностики: прочитать параметр, записать параметр, получить сведения об ошибках, задать режим работы.
        \item PDO (Process Data Objects) - наоборот, канал для оперативных данных “процесса” в реальном времени: короткие сообщения, минимальные накладные расходы, рассчитанные на регулярный обмен командами и обратной связью.
    \end{itemize}
    В инженерных терминах: SDO - чтобы настроить и проверить, PDO - чтобы работать. 
    Отдельно в этот же ряд обычно ставят NMT (Network Management) - механизм управления сетью и состояниями устройств: 
    он отвечает за то, в каком режиме сейчас находится узел и можно ли ему “доверять” процессный обмен.

    \item \textbf{CANopen-автомат.} 
    CANopen - формализованная модель состояний узла и управление ими через NMT. 
    Для CANopen устройство не просто “подключено к CAN”, оно находится в одном из определённых состояний (например, состояние для настройки, для нормальной работы, для остановки).
    Это важно потому, что многие действия допустимы не всегда: типично конфигурацию делают в состоянии, где устройство ещё не участвует в процессном обмене, а затем переводят узел в рабочее состояние.
    В этой модели управляющий узел может переводить другие узлы между состояниями - например, выполнить reset.
    В результате сеть становится более предсказуемой: запуск системы - это не “каждый стартует как хочет”, а воспроизводимый сценарий.

    \item \textbf{Object Dictionary (OD), словарь объектов устройства.} 
    Это ключевая “семантическая база” CANopen: каждый узел содержит таблицу параметров, команд и диагностических полей, организованную как адресуемые записи. 
    Именно OD определяет, что означает конфигурация устройства и как к ней обращаться. 
    Практический смысл простой: вместо того чтобы каждый производитель придумывал свой способ настройки, CANopen говорит “все параметры лежат в словаре, к ним обращаются стандартным способом”. 
    Доступ к OD чаще всего идёт через SDO: клиент читает/пишет конкретные элементы словаря. 
    Поэтому OD и SDO концептуально связаны: OD - это модель данных, SDO - стандартный инструмент доступа.

    \item \textbf{EDS (Electronic Data Sheet), электронная спецификация словаря объектов.} 
    Если OD - это содержимое внутри устройства, то EDS - формализованное описание этого содержимого “снаружи”, в стандартном файловом формате. 
    Его ценность проявляется в инструментах: сервисные утилиты и конфигураторы могут загрузить EDS и понять, какие параметры существуют, какие типы данных и прочее. 
    Это снижает зависимость от ручной интеграции и облегчает обслуживание.

    \item \textbf{DCF (Device Configuration File), профили устройств.} 
    Предположим, завод приобрел сервомотор ServoMotor3000 для интеграции в конвейерную ленту.
    При этом оператор редактирует EDS устройства, добавляя специфические для интеграции данные, например, указывая битрейт устройства и идентификатор узла. 
    Модифицированный EDS можно экспортировать в виде файла конфигурации устройства (DCF).
\end{enumerate}

Логичным продолжением разговора о CANopen становится вопрос о практической реализации: 
какие программные средства позволяют “оживить” описанные концепты в коде и связать их с реальной CAN-шиной. 
На этом этапе фокус смещается от протокольной модели к инженерному инструментарию: 
драйверам и библиотекам для работы с CAN, а также к стеку или фреймворку, 
который берёт на себя CANopen-логику либо предоставляет удобные примитивы для её построения.

Исторически и индустриально сложилось так, что основная масса библиотек и стеков для CAN и CANopen реализована на C (C++). 
Причина тривиальна: C уже долгое время доминирует в embedded-разработке, где CAN наиболее распространён; 
он обеспечивает предсказуемость по ресурсам, простоту портирования на микроконтроллеры и хорошую совместимость с существующими драйверами и RTOS. 
Поэтому именно в C-экосистеме накоплен максимальный объём “полевого” опыта: 
от базового доступа к CAN-интерфейсу до полноценных CANopen-стеков, профилей устройств и обвязки вокруг конфигурации.

В этом смысле рассматриваемая область давно "закрыта" с точки зрения рассматриваемых решений. 
Однако сама языковая база, на которой держится эта экосистема, заметно устарела: 
C остаётся эффективным и привычным, но его модель безопасности и контроля ошибок всё хуже соответствует современным требованиям к надёжности, 
сопровождаемости и устойчивости системного кода.

Сегодня Rust всё чаще рассматривается как естественный преемник C для задач низкоуровневого программирования: 
он сохраняет возможность работать близко к железу и контролировать ресурсы и при этом предлагает более строгие гарантии корректности.
Однако, фреймворки и библиотеки для CAN/CANopen на Rust заметно малочисленнее, чем их аналоги на C, и в среднем находятся на более ранней стадии зрелости. 
Для многих проектов характерны ограничения по полноте реализации, менее стабильные API, а также меньшая проверенность в долгоживущих промышленных системах.
Иными словами, Rust экосистема остаётся фрагментированной и в значительной мере незаполненной. 
Именно этот вакуум и определяет мотивацию дальнейшей работы.

Далее будут рассмотрены конкретные решения для работы с CAN и CANopen, их архитектурные подходы, зрелость и границы применимости.

%\begin{note}
%Дописать введение и нормально подвести к конкретным решениям:
%\begin{itemize}
%    \item Zencan
%    \item canopen
%    \item canopen\_rust
%    \item Вероятнее всего рассмотреть решения на C
%\end{itemize}
%\end{note}


\tocsection{ЗАКЛЮЧЕНИЕ}

\pagebreak

\addcontentsline{toc}{section}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\printbibliography

\pagebreak

\renewcommand{\appendixpagename}{\centering Приложения}

%\begin{appendices}

%\renewcommand{\thesection}{\Asbuk{section}}

%\makeatletter
%\renewcommand{\theProgram}{\thesection.\@arabic\c@Program}
%\makeatother

%\section{\centering}
%\setcounter{Program}{0}

%\begin{flushleft}
%\needspace{3\baselineskip}
%\captionof{Program}{Часть кода реализации класса HashMapValue}\label{app1}
%\begin{MyCodes}
%public class HashMapValue {
%    protected String filename;
%    protected HashMap<String, String> hashValue = new HashMap<>();
%    protected HashMap<String, Boolean> hashKeysFlag = new HashMap<>();
%}
%\end{MyCodes}
%\end{flushleft}

%\pagebreak

%\begin{flushleft}
%\captionof{Program}{Пример кода}\label{app2}
%\begin{MyCodes}
%код второго приложения
%\end{MyCodes}
%\end{flushleft}

%\end{appendices}

\end{document}
